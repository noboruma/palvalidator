# Statistics Library (`libs/statistics`)

## Overview

The `statistics` library within the `palvalidator` project provides a comprehensive suite of tools for the statistical validation and robustness testing of trading strategies. It is designed to assess the performance of strategies generated by Price Action Lab (PAL) and other systems, employing various techniques ranging from basic descriptive statistics to advanced Monte Carlo simulations and multiple testing corrections.

The library is templated on a `Decimal` type, allowing for flexibility in numerical precision. It heavily utilizes policy-based design to customize aspects of tests, such as how test statistics are computed, how results are collected and returned, and how parallel execution is handled.

## Core Concepts

The library revolves around a few core concepts:

* **Strategy Performance Evaluation**: Calculating various metrics to describe how a trading strategy has performed on historical or synthetic data.
* **Hypothesis Testing**: Using statistical tests, particularly permutation tests, to determine if observed strategy performance is statistically significant or likely due to chance.
* **Robustness Analysis**: Assessing how sensitive a strategy's performance is to small changes in its parameters or market conditions.
* **Multiple Testing Correction**: Adjusting p-values when multiple strategies or hypotheses are tested simultaneously to control the family-wise error rate (FWER) or false discovery rate (FDR).
* **Policy-Based Design**: Allowing flexible customization of algorithms by injecting specific behaviors (policies) for computation, result handling, and parallel execution.

## Major Classes and Their Roles

### 1. Data Preparation and Basic Metrics

* **`Returns<Decimal>` (`Returns.h`)**:
    * **Intent**: Provides utility functions to calculate simple and percentage returns between two price points.
    * **Interaction**: Used by various components that need to calculate returns as a basis for performance metrics.

* **`SummaryStats<Decimal>` (`SummaryStats.h`)**:
    * **Intent**: A class to accumulate a series of decimal values and compute basic summary statistics like median, min/max values, and the robust Qn estimator of scale.
    * **Interaction**: Used within robustness testing (`RobustnessCalculator`) and potentially other areas where a quick summary of a distribution of values is needed.

* **`StatUtils<Decimal>` (`StatUtils.h`)**:
    * **Intent**: A struct containing static utility methods for common financial statistics, such as Profit Factor and Log Profit Factor, calculated from a vector of returns.
    * **Interaction**: Leveraged by test policies (e.g., `AllHighResLogPFPolicy` in `MonteCarloTestPolicy.h`) to derive performance metrics.

* **`StrategyDataPreparer<Decimal, BaselineStatPolicy, Executor>` (`StrategyDataPreparer.h`)**:
    * **Intent**: A stateless utility to build `PalStrategy` objects from PAL patterns and run baseline backtests to compute an initial performance statistic for each strategy. This is often the first step before more complex validation.
    * **Interaction**: Uses `PalStrategy`, `BackTester`, and a `BaselineStatPolicy` (see `MonteCarloTestPolicy.h`) to get the performance metric. Produces a `StrategyDataContainer` (defined in `PALMonteCarloTypes.h`) which is consumed by validation algorithms like `PALMastersMonteCarloValidation`.

* **`PALMonteCarloTypes.h`**:
    * **Intent**: Defines shared data structures used across Monte Carlo validation components, primarily:
        * `StrategyContext<Decimal>`: Holds a strategy pointer, its baseline statistic, and a count.
        * `StrategyDataContainer<Decimal>`: A vector of `StrategyContext`.
    * **Interaction**: These types are fundamental for passing around collections of strategies and their initial performance data.

### 2. Monte Carlo Permutation Testing Framework

This framework is designed to assess the statistical significance of a trading strategy's performance by comparing its observed metric against a distribution of metrics from permuted (randomized) data.

* **`MonteCarloPermutationTest<Decimal, ReturnType>` (`MonteCarloPermutationTest.h`)**:
    * **Intent**: An abstract base class defining the interface for Monte Carlo permutation tests. It provides common utility methods like `getNumClosedTrades` and `getCumulativeReturn`.
    * **Interaction**: Subclassed by concrete permutation test implementations like `MonteCarloPermuteMarketChanges` and `OriginalMCPT`.

* **`MonteCarloPermuteMarketChanges<Decimal, _BackTestResultPolicy, _ComputationPolicy>` (`MonteCarloPermutationTest.h`)**:
    * **Intent**: Implements a Monte Carlo Permutation Test (MCPT) by creating synthetic time series and permuting market changes. It uses a `_BackTestResultPolicy` to define the performance statistic and a `_ComputationPolicy` to manage the permutation and p-value calculation.
    * **Interaction**: Uses `BackTester`, `SyntheticTimeSeries` (from `libs/timeseries`), and various policies. `_BackTestResultPolicy` examples are found in `MonteCarloTestPolicy.h`. `_ComputationPolicy` example is `DefaultPermuteMarketChangesPolicy`.

* **`OriginalMCPT<Decimal>` (`MonteCarloPermutationTest.h`)**:
    * **Intent**: Implements the MCPT by shuffling the *position vectors* (buy/sell signals) of a strategy, as described in "Monte-Carlo Evaluation of Trading Systems." This is an alternative to permuting market data.
    * **Interaction**: Uses `BackTester` and operates on the strategy's trade sequence.

* **`MonteCarloPayoffRatio<Decimal>` (`MonteCarloPermutationTest.h`)**:
    * **Intent**: Uses Monte Carlo simulation with synthetic time series to derive a robust estimate of a strategy's payoff ratio by aggregating results from many backtests.
    * **Interaction**: Similar to `MonteCarloPermuteMarketChanges` but focuses on calculating the median payoff ratio from many simulations.

* **Policy Classes for Permutation Testing**:
    * **`MonteCarloTestPolicy.h`**: Defines policies for how a test statistic is extracted from a backtest.
        * `AllHighResLogPFPolicy`: Computes log-profit-factor over all bar-by-bar returns.
        * `NonGranularProfitFactorPolicy`: Uses the profit factor from closed positions.
        * `CumulativeReturnPolicy`: Uses the total cumulative return.
        * `NormalizedReturnPolicy`: Computes a return normalized by time in market and trading opportunities.
        * `PalProfitabilityPolicy`: Uses Price Action Lab's profitability metric.
        * `PessimisticReturnRatioPolicy`: Uses a pessimistic return ratio.
    * **`PermutationTestComputationPolicy.h`**:
        * `DefaultPermuteMarketChangesPolicy`: Implements the core logic for running permutations, handling parallel execution (via an `Executor` policy), collecting results, and calculating p-values. It uses a `_PermutationTestResultPolicy` to define the return type and a `_PermutationTestStatisticsCollectionPolicy` to aggregate statistics across permutations.
    * **`PermutationTestResultPolicy.h`**: Defines how results from permutation tests are structured and collected.
        * `PValueReturnPolicy`: Returns just the p-value.
        * `PValueAndTestStatisticReturnPolicy`: Returns a tuple of p-value and the test statistic.
        * `PermutationTestingMaxTestStatisticPolicy`: Collects the maximum observed test statistic during permutations.
        * `PermutationTestingNullTestStatisticPolicy`: Collects no summary test statistics (used when only p-value is needed).
    * **`MonteCarloTestResultPolicy.h`**:
        * `DefaultTestResultPolicy`: (Appears incomplete in the provided file) Likely intended as a basic policy for returning results.

### 3. Robustness Testing

These classes assess how a strategy's performance changes when its parameters (like profit targets and stop-losses) are varied slightly.

* **`RobustnessTest.h`**:
    * **`PatternRobustnessCriteria<Decimal>`**: Defines the criteria for a pattern to be considered robust (e.g., minimum robustness index, desired profit factor, tolerance levels).
    * **`RobustnessPermutationAttributes` (and derived `PALRobustnessPermutationAttributes`, `StatSignificantAttributes`)**: Defines parameters for how permutations are performed during robustness testing (number of permutations, how many to check at extremes).
    * **`ProfitTargetStopPair<Decimal>`**: A simple struct to hold a profit target and stop-loss pair.
    * **`RobustnessTestResult<Decimal>`**: Stores the outcome of a single permutation in a robustness test (win rate, profit factor, num trades, payoff ratios, expectancy).
    * **`RobustnessCalculator<Decimal>`**: Calculates the overall robustness of a pattern by aggregating multiple `RobustnessTestResult` objects from different parameter permutations. It determines if a pattern meets the `PatternRobustnessCriteria`.
    * **`RobustnessTest<Decimal>`**: Orchestrates a series of backtests for a single PAL strategy with varied profit target/stop-loss parameters (permutations) and uses `RobustnessCalculator` to evaluate overall robustness.
    * **`RobustnessTestMonteCarlo<Decimal>`**: Similar to `RobustnessTest` but incorporates Monte Carlo simulation to estimate payoff ratios for each parameter permutation, aiming for more stable results.

* **`RobustnessTester.h`**:
    * **`PalRobustnessTester<Decimal>`**: An abstract base class for testing the robustness of a group of PAL patterns. It manages a list of strategies, runs robustness tests on them (using `RobustnessTestMonteCarlo`), and categorizes them as surviving or rejected based on `PatternRobustnessCriteria`.
    * **`PalStandardRobustnessTester<Decimal>`**: A concrete implementation of `PalRobustnessTester` with predefined permutation attributes and robustness criteria.
    * **`StatisticallySignificantRobustnessTester<Decimal>`**: Another concrete implementation with different default attributes, likely aiming for stricter statistical significance.

* **`LogRobustnessTest.h`**:
    * **`LogRobustnessTest<Decimal>`**: Provides static utility methods to log the detailed results and summary statistics from a `RobustnessCalculator` to an output file stream.

### 4. Multiple Testing Correction and Advanced Validation

When testing many strategies or hypotheses simultaneously, these components help to control for the increased chance of finding "significant" results purely by luck.

* **`MultipleTestingCorrection.h`**:
    * **`BaseStrategyContainer<Decimal>`**: A common container used by various correction policies to store strategies sorted by a key (e.g., p-value) and to manage a list of surviving strategies.
    * **`TestStatisticStrategyImplementation<Decimal>`**: A container designed to hold strategy results including a p-value and a test statistic (like max test stat from permutations). Used by more advanced correction methods.
    * **Correction Policies**:
        * `BenjaminiHochbergFdr<Decimal>`: Implements the Benjamini-Hochberg procedure to control the False Discovery Rate (FDR).
        * `AdaptiveBenjaminiHochbergYr2000<Decimal>`: An adaptive version of the Benjamini-Hochberg procedure.
        * `UnadjustedPValueStrategySelection<Decimal>`: A simple policy that selects strategies based on their raw (unadjusted) p-values against a significance threshold.
        * `RomanoWolfStepdownCorrection<Decimal>`: Implements the Romano-Wolf step-down procedure for strong control of the Family-Wise Error Rate (FWER), using empirical p-values derived from resampling.
        * `HolmRomanoWolfCorrection<Decimal>`: Combines Romano-Wolf empirical p-values with Holm's sequential adjustment method.
    * **`detail::prepareContainerAndNull` and `detail::adjustPValues`**: Internal helper functions used by the Romano-Wolf style correction policies to sort data, build empirical null distributions, and apply step-down/step-up p-value adjustments.

* **`PALMonteCarloValidation.h`**:
    * **`PALMonteCarloValidationBase<Decimal, McptType, _StrategySelection>`**: An abstract base class for orchestrating Monte Carlo validation of multiple PAL strategies. It uses a specific `McptType` (Monte Carlo Permutation Test type) and a `_StrategySelection` policy (from `MultipleTestingCorrection.h`) to manage results and apply corrections.
    * **`PALMonteCarloValidation<Decimal, McptType, _StrategySelection, Executor>`**: A concrete implementation that runs a specified `McptType` for each strategy (potentially in parallel via `Executor`) and then applies the chosen `_StrategySelection` policy (which includes multiple testing correction) to determine surviving strategies.
    * **`PALMCPTValidation<Decimal>`**: An older (?) or alternative validation class that uses `OriginalMCPT` (position vector shuffling) for its permutation tests and a simpler p-value threshold for selection, without the explicit multiple testing correction framework of the more generic `PALMonteCarloValidation`.

* **`IMastersSelectionBiasAlgorithm.h`**:
    * **`IMastersSelectionBiasAlgorithm<Decimal, BaselineStatPolicy>`**: Defines an interface for algorithms designed to address selection bias, particularly in the context of Timothy Masters' work. These algorithms typically take a set of strategies with baseline statistics and return adjusted p-values.

* **`MastersPermutationTestComputationPolicy.h`**:
    * **`MastersPermutationPolicy<Decimal, BaselineStatPolicy, Executor>`**: A computation policy used within stepwise multiple testing procedures (like Masters/Romano-Wolf). For a given strategy and the currently *active* set of other strategies, it computes how many permutations result in a max statistic (from the active set) exceeding the strategy's baseline statistic.
    * **`FastMastersPermutationPolicy<Decimal, BaselineStatPolicy, Executor>`**: An optimized version that computes exceedance counts for *all* strategies in a single parallel Monte Carlo sweep, improving efficiency.

* **`MastersRomanoWolf.h`**:
    * **`MastersRomanoWolf<Decimal, BaselineStatPolicy>`**: Implements a stepwise multiple testing procedure based on Masters' adaptation of Romano-Wolf. It iteratively tests strategies, shrinking the set of active strategies and re-computing null distributions based on the remaining ones. Uses `MastersPermutationPolicy`.

* **`MastersRomanoWolfImproved.h`**:
    * **`MastersRomanoWolfImproved<Decimal, BaselineStatPolicy>`**: An improved, faster version of the Masters/Romano-Wolf algorithm. It uses `FastMastersPermutationPolicy` to compute all permutation counts in one pass, then applies a step-down inclusion loop. This is generally more efficient.

* **`PALMastersMonteCarloValidation.h`**:
    * **`PALMastersMonteCarloValidation<Decimal, BaselineStatPolicy>`**: Orchestrates the validation of PAL strategies using one of the Masters/Romano-Wolf algorithms (via `IMastersSelectionBiasAlgorithm`). It first prepares strategy data with baseline stats using `StrategyDataPreparer`, then invokes the chosen algorithm (e.g., `MastersRomanoWolfImproved` by default) to get adjusted p-values, and finally uses `UnadjustedPValueStrategySelection` (applied to the *adjusted* p-values) to filter strategies.

## Key Interactions and Workflows

1.  **Basic Permutation Test for a Single Strategy**:
    * A `BackTester` object is configured with a single `PalStrategy`.
    * An `McptType` (e.g., `MonteCarloPermuteMarketChanges`) is instantiated with the `BackTester` and number of permutations.
    * The `runPermutationTest()` method of the `McptType` is called.
        * This internally uses a `BackTestResultPolicy` (e.g., `AllHighResLogPFPolicy`) to get the baseline statistic and statistics from permuted runs.
        * It uses a `ComputationPolicy` (e.g., `DefaultPermuteMarketChangesPolicy`) to manage the permutation loop, parallel execution, and p-value calculation.
        * The result (e.g., p-value) is returned according to a `PermutationTestResultPolicy` (e.g., `PValueReturnPolicy`).

2.  **Robustness Testing of PAL Patterns**:
    * A `PalRobustnessTester` (e.g., `PalStandardRobustnessTester`) is created with a prototype `BackTester`.
    * `PalStrategy` objects are added to the tester.
    * `runRobustnessTests()` is called.
        * For each strategy, a `RobustnessTestMonteCarlo` instance is created.
        * `RobustnessTestMonteCarlo::runRobustnessTest()` iterates through permutations of profit targets and stop-losses for the strategy.
            * For each parameter permutation, it runs a backtest.
            * It uses `MonteCarloPayoffRatio` to get a stable payoff ratio estimate for that parameter set.
            * A `RobustnessTestResult` is created.
        * These results are fed into a `RobustnessCalculator` associated with the strategy.
        * The `RobustnessCalculator::isRobust()` method then evaluates if the strategy meets the `PatternRobustnessCriteria` based on the distribution of results from parameter permutations.
    * Strategies are classified as surviving or rejected. Results can be logged using `LogRobustnessTest`.

3.  **Validation of Multiple Strategies with Multiple Testing Correction (General PAL Approach)**:
    * An instance of `PALMonteCarloValidation` is created, configured with the number of permutations, the desired `McptType` (e.g., `MonteCarloPermuteMarketChanges` with specific policies), and a `_StrategySelection` policy (e.g., `RomanoWolfStepdownCorrection`).
    * `runPermutationTests()` is called with the base security, PAL patterns, and date range.
        * For each pattern, a `PalStrategy` is created.
        * The specified `McptType` is run for each strategy (often in parallel).
        * The raw results (e.g., p-value and possibly a max test statistic if required by the selection policy) are collected by the `_StrategySelection` policy.
        * After all strategies are tested, the `_StrategySelection` policy's `correctForMultipleTests()` method is called, which applies the chosen multiple testing correction algorithm (e.g., Romano-Wolf) using the collected raw p-values and/or test statistics.
        * Surviving strategies are then available through iterators.

4.  **Validation of Multiple Strategies with Masters/Romano-Wolf Stepwise Procedure**:
    * An instance of `PALMastersMonteCarloValidation` is created, configured with the number of permutations and an implementation of `IMastersSelectionBiasAlgorithm` (e.g., `MastersRomanoWolfImproved` by default). A `BaselineStatPolicy` (e.g., `AllHighResLogPFPolicy`) is also implicitly defined by the template.
    * `runPermutationTests()` is called.
        * `StrategyDataPreparer` is used to generate `PalStrategy` objects and their baseline performance statistics based on the `BaselineStatPolicy`.
        * The `strategyData` is sorted by the baseline statistic (best performing first).
        * The chosen `IMastersSelectionBiasAlgorithm` (e.g., `MastersRomanoWolfImproved::run()`) is invoked.
            * This algorithm performs the stepwise permutation testing. `MastersRomanoWolfImproved` uses `FastMastersPermutationPolicy` to efficiently get exceedance counts for all strategies in one go.
            * It then applies a step-down adjustment to calculate final p-values for each strategy, controlling FWER.
        * The resulting map of strategies to adjusted p-values is processed by `UnadjustedPValueStrategySelection` (acting on the *adjusted* p-values) to filter survivors based on the significance level.

## Workflow Summary

Generally, data flows from basic calculations (`Returns`, `StatUtils`) to strategy performance evaluation (`BackTester` in `libs/backtesting`). This performance is then rigorously tested using:
* Permutation tests (`MonteCarloPermutationTest` and its variants) to assess statistical significance.
* Robustness tests (`RobustnessTester`, `RobustnessTest`) to check stability against parameter changes.
* Advanced validation frameworks (`PALMonteCarloValidation`, `PALMastersMonteCarloValidation`) that combine these tests with multiple testing corrections (`MultipleTestingCorrection` policies) to ensure reliable selection of strategies from a larger pool.

Policy classes are key to customizing the details of these statistical procedures, providing flexibility and modularity to the library.
