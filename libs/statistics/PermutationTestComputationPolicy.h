// Copyright (C) MKC Associates, LLC - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Michael K. Collison <collison956@gmail.com>, November 2017
//
#ifndef __PERMUTATION_TEST_COMPUTATION_POLICY_H
#define __PERMUTATION_TEST_COMPUTATION_POLICY_H 1

#include <exception>
#include <string>
#include <atomic>
#include <mutex>
#include <thread>
#include "number.h"
#include "DecimalConstants.h"
#include "BackTester.h"
#include "SyntheticTimeSeries.h"
#include "MonteCarloTestPolicy.h"
#include "SyntheticSecurityHelpers.h"
#include "PermutationTestResultPolicy.h"
#include "ParallelExecutors.h"
#include "ParallelFor.h"

namespace mkc_timeseries
{
  /**
   * @class DefaultPermuteMarketChangesPolicy
   * @brief Performs a hypothesis test via Monte-Carlo permutation testing of a trading strategy.
   *
   * This class implements a Monte-Carlo permutation testing methodology to evaluate
   * the statistical significance of a trading strategy's performance. It operates on a
   * trading strategy represented by the `BacktesterStrategy` class and utilizes a
   * backtesting engine provided by the `BackTester` class.
   *
   * The core principle involves permuting market changes to generate multiple synthetic
   * market scenarios. The strategy is then backtested on these scenarios to create a
   * distribution of performance metrics, which is used to assess the likelihood that
   * the original strategy's performance was due to chance.
   *
   * @tparam Decimal The numerical type used for calculations (e.g., double, mkc_timeseries::number).
   *
   * @tparam BackTestResultPolicy A policy class that defines how to extract the relevant
   * test statistic from a backtest result. It is expected to be
   * a class like `AllHighResLogPFPolicy`, which extracts a
   * high-resolution profit factor. This policy must define:
   * - `static Decimal getPermutationTestStatistic(std::shared_ptr<BackTester<Decimal>>)`
   * - `static uint32_t getMinStrategyTrades()`
   *
   * @tparam _PermutationTestResultPolicy A policy class determining the return type of the
   * `runPermutationTest` method. It must define a nested
   * type `ReturnType` and a static method
   * `createReturnValue(Decimal pValue, Decimal summaryTestStat)`.
   * Defaults to `PValueReturnPolicy<Decimal>`.
   *
   * @tparam _PermutationTestStatisticsCollectionPolicy A policy class used to determine if and how
   * backtester statistics are collected across multiple permutations. These statistics can
   * be used by multiple-testing correction algorithms.
   *
   * It must implement:
   * - `void updateTestStatistic(Decimal)`
   * - `Decimal getTestStat()`
   * Defaults to `PermutationTestingNullTestStatisticPolicy<Decimal>`.
   * @tparam Executor A policy class that defines the execution model for permutations,
   * specifically whether concurrency is used. Defaults to `concurrency::StdAsyncExecutor`.
   */
  template <class Decimal,
	    class BackTestResultPolicy,
	    typename _PermutationTestResultPolicy = PValueReturnPolicy<Decimal>,
	    typename _PermutationTestStatisticsCollectionPolicy = PermutationTestingNullTestStatisticPolicy<Decimal>,
	    typename Executor = concurrency::ThreadPoolExecutor<>>
  class DefaultPermuteMarketChangesPolicy
  {
    static_assert(has_return_type<_PermutationTestResultPolicy>::value,
		  "_PermutationTestResultPolicy must define a nested ::ReturnType");
    static_assert(has_create_return_value<_PermutationTestResultPolicy>::value,
		  "_PermutationTestResultPolicy must have static createReturnValue(Decimal, Decimal)");
    static_assert(has_update_test_statistic<_PermutationTestStatisticsCollectionPolicy>::value,
		  "_PermutationTestStatisticsCollectionPolicy must implement updateTestStatistic(Decimal)");
    static_assert(has_get_test_stat<_PermutationTestStatisticsCollectionPolicy>::value,
		  "_PermutationTestStatisticsCollectionPolicy must implement getTestStat()");
  public:
    using ReturnType = typename _PermutationTestResultPolicy::ReturnType;

    DefaultPermuteMarketChangesPolicy()
    {}

    ~DefaultPermuteMarketChangesPolicy()
    {}

    /**
     * @brief Executes the Monte-Carlo permutation test for a given trading strategy.
     *
     * This method performs the permutation test by:
     *
     * 1. For each permutation:
     * a. Cloning the original strategy and backtester.
     * b. Creating a synthetic portfolio with permuted market data derived from the original security.
     * This step is repeated if the number of trades generated by the cloned strategy on the
     * synthetic data is less than a minimum threshold (defined by `BackTestResultPolicy::getMinStrategyTrades()`).
     * c. Running the backtest for the cloned strategy on the synthetic market data.
     * d. Computing a test statistic for this permutation using `BackTestResultPolicy::getPermutationTestStatistic()`.
     * e. Comparing the permutation's test statistic with the `baseLineTestStat`.
     * f. Updating a collection of test statistics via `_PermutationTestStatisticsCollectionPolicy` (thread-safe)
     *.
     * 2. These steps are executed in parallel for all permutations, as governed by the `Executor` policy.
     *
     * 3. Calculating the p-value as the proportion of permutations whose test statistic is greater than or
     * equal to the `baseLineTestStat`.
     *
     * 4. Obtaining a summary test statistic from the `_PermutationTestStatisticsCollectionPolicy`.
     *
     * 5. Returning the results as defined by the `_PermutationTestResultPolicy`.
     *
     * @param theBackTester A shared pointer to a `BackTester<Decimal>` object, which
     * encapsulates the backtesting engine and the trading strategy.
     * @param numPermutations The number of permutations (synthetic backtests) to run.
     * @param baseLineTestStat The test statistic obtained from running the strategy on the
     * original, unpermuted market data. This serves as the benchmark.
     * @return ReturnType The result of the permutation test, with its type determined by
     * the `_PermutationTestResultPolicy`. This typically includes the p-value
     * and may include a summary test statistic from the permutations.
     */
    static ReturnType
    runPermutationTest(std::shared_ptr<BackTester<Decimal>> theBackTester,
                   uint32_t numPermutations,
                   const Decimal& baseLineTestStat)
    {
      if (numPermutations == 0)
	throw std::invalid_argument("DefaultPermuteMarketChangesPolicy::runPermutationTest: numPermutations must be > 0");

      // Grab the one strategy and its security
      auto aStrategy   = *(theBackTester->beginStrategies());
      auto theSecurity = aStrategy->beginPortfolio()->second;

      // Minimum trades threshold
      const uint32_t minTrades = BackTestResultPolicy::getMinStrategyTrades();

      // Atomics for counting valid permutations and “extreme” ones
      std::atomic<uint32_t> validPerms{0}, extremeCount{0};

      // For collecting any summary statistic (e.g. max‐statistic)
      _PermutationTestStatisticsCollectionPolicy testStatCollector;
      std::mutex                                 testStatMutex;

      // Work lambda for one permutation
      auto work = [=, &validPerms, &extremeCount, &testStatCollector, &testStatMutex]
	(uint32_t /*permIndex*/)
      {
        // 1) Clone & backtest
        auto clonedStrat = aStrategy->clone(
					    createSyntheticPortfolio<Decimal>(theSecurity,
									      aStrategy->getPortfolio()));
        auto clonedBT = theBackTester->clone();
        clonedBT->addStrategy(clonedStrat);
        clonedBT->backtest();

        // 2) Count trades; skip if below threshold
        uint32_t stratTrades =
	  BackTesterFactory<Decimal>::getNumClosedTrades(clonedBT);
        if (stratTrades < minTrades) {
	  return;  // uninformative — do not increment validPerms
        }

        // 3) Valid permutation: compute statistic
        Decimal testStat =
	  BackTestResultPolicy::getPermutationTestStatistic(clonedBT);

        // 4) Update atomics
        validPerms.fetch_add(1, std::memory_order_relaxed);
        if (testStat >= baseLineTestStat) {
	  extremeCount.fetch_add(1, std::memory_order_relaxed);
        }

        // 5) Update the summary‐statistic policy under lock
        {
	  std::lock_guard<std::mutex> guard(testStatMutex);
	  testStatCollector.updateTestStatistic(testStat);
        }
      };

      // Execute in parallel
      Executor executor{};
      concurrency::parallel_for(numPermutations, executor, work);

      // 6) Final p‐value calculation over only the valid permutations
      uint32_t valid = validPerms.load(std::memory_order_relaxed);
      if (valid == 0) {
        // no informative draws → cannot reject null
        return _PermutationTestResultPolicy::createReturnValue(
							       Decimal(1), testStatCollector.getTestStat());
      }

      uint32_t extreme = extremeCount.load(std::memory_order_relaxed);
      Decimal pValue = computePermutationPValue(extreme, valid);

      // 7) Grab whatever summary the statistics‐collection policy holds
      Decimal summaryTestStat = testStatCollector.getTestStat();

      // 8) Return in the shape the ResultPolicy demands
      return _PermutationTestResultPolicy::createReturnValue(pValue,
							     summaryTestStat);
    }

    /**
     * @brief Computes a bias-corrected Monte Carlo permutation test p-value.
     *
     * Applies the “+1” correction often recommended in the permutation-testing literature
     * (e.g. Good 2005; North et al. 2002) to avoid zero p-values and to yield an unbiased
     * small-sample estimate.  Given:
     *   - k = number of permutations whose test statistic ≥ the observed statistic
     *   - N = total number of permutations run
     *
     * this returns
     * \f[
     *    p \;=\; \frac{k + 1}{\,N + 1\,}
     * \f]
     *
     * which enforces a minimum p-value of \(1/(N+1)\) when \(k=0\).
     *
     * @param k
     *   Count of “extreme” permutations (i.e. ones at least as good as baseline).
     * @param N
     *   Total number of permutations executed.
     * @return
     *   A bias-corrected p-value in the interval \([1/(N+1),\,1]\).
     */
    static Decimal computePermutationPValue(std::uint32_t k,
                                            std::uint32_t N)
    {
      return Decimal(k + 1) / Decimal(N + 1);
    }
  };
}
#endif
