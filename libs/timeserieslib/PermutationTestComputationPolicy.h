// Copyright (C) MKC Associates, LLC - All Rights Reserved
// Unauthorized copying of this file, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Michael K. Collison <collison956@gmail.com>, November 2017
//
#ifndef __PERMUTATION_TEST_COMPUTATION_POLICY_H
#define __PERMUTATION_TEST_COMPUTATION_POLICY_H 1

#include <exception>
#include <string>
#include <atomic>
#include <mutex>
#include <thread>
#include "number.h"
#include "DecimalConstants.h"
#include "BackTester.h"
#include "SyntheticTimeSeries.h"
#include "MonteCarloTestPolicy.h"
#include "SyntheticSecurityHelpers.h"
#include "PermutationTestResultPolicy.h"
#include "ParallelExecutors.h"
#include "ParallelFor.h"

namespace mkc_timeseries
{
  static constexpr std::size_t kInnerThreads =
    std::thread::hardware_concurrency() > 0
    ? std::thread::hardware_concurrency()
    : 2;  // fallback if hardware_concurrency() is zero

  /**
   * @class DefaultPermuteMarketChangesPolicy
   * @brief Performs a hypothesis test via Monte-Carlo permutation testing of a trading strategy.
   *
   * This class implements a Monte-Carlo permutation testing methodology to evaluate
   * the statistical significance of a trading strategy's performance. It operates on a
   * trading strategy represented by the `BacktesterStrategy` class and utilizes a
   * backtesting engine provided by the `BackTester` class.
   *
   * The core principle involves permuting market changes to generate multiple synthetic
   * market scenarios. The strategy is then backtested on these scenarios to create a
   * distribution of performance metrics, which is used to assess the likelihood that
   * the original strategy's performance was due to chance.
   *
   * @tparam Decimal The numerical type used for calculations (e.g., double, mkc_timeseries::number).
   *
   * @tparam BackTestResultPolicy A policy class that defines how to extract the relevant
   * test statistic from a backtest result. It is expected to be
   * a class like `AllHighResLogPFPolicy`, which extracts a
   * high-resolution profit factor. This policy must define:
   * - `static Decimal getPermutationTestStatistic(std::shared_ptr<BackTester<Decimal>>)`
   * - `static uint32_t getMinStrategyTrades()`
   *
   * @tparam _PermutationTestResultPolicy A policy class determining the return type of the
   * `runPermutationTest` method. It must define a nested
   * type `ReturnType` and a static method
   * `createReturnValue(Decimal pValue, Decimal summaryTestStat)`.
   * Defaults to `PValueReturnPolicy<Decimal>`.
   *
   * @tparam _PermutationTestStatisticsCollectionPolicy A policy class used to determine if and how
   * backtester statistics are collected across multiple permutations. These statistics can
   * be used by multiple-testing correction algorithms.
   *
   * It must implement:
   * - `void updateTestStatistic(Decimal)`
   * - `Decimal getTestStat()`
   * Defaults to `PermutationTestingNullTestStatisticPolicy<Decimal>`.
   * @tparam Executor A policy class that defines the execution model for permutations,
   * specifically whether concurrency is used. Defaults to `concurrency::StdAsyncExecutor`.
   */
  template <class Decimal,
	    class BackTestResultPolicy,
	    typename _PermutationTestResultPolicy = PValueReturnPolicy<Decimal>,
	    typename _PermutationTestStatisticsCollectionPolicy = PermutationTestingNullTestStatisticPolicy<Decimal>,
	    typename Executor = concurrency::ThreadPoolExecutor<kInnerThreads>>
  class DefaultPermuteMarketChangesPolicy
  {
    static_assert(has_return_type<_PermutationTestResultPolicy>::value,
		  "_PermutationTestResultPolicy must define a nested ::ReturnType");
    static_assert(has_create_return_value<_PermutationTestResultPolicy>::value,
		  "_PermutationTestResultPolicy must have static createReturnValue(Decimal, Decimal)");
    static_assert(has_update_test_statistic<_PermutationTestStatisticsCollectionPolicy>::value,
		  "_PermutationTestStatisticsCollectionPolicy must implement updateTestStatistic(Decimal)");
    static_assert(has_get_test_stat<_PermutationTestStatisticsCollectionPolicy>::value,
		  "_PermutationTestStatisticsCollectionPolicy must implement getTestStat()");
  public:
    using ReturnType = typename _PermutationTestResultPolicy::ReturnType;

    DefaultPermuteMarketChangesPolicy()
    {}

    ~DefaultPermuteMarketChangesPolicy()
    {}

    /**
     * @brief Executes the Monte-Carlo permutation test for a given trading strategy.
     *
     * This method performs the permutation test by:
     *
     * 1. For each permutation:
     * a. Cloning the original strategy and backtester.
     * b. Creating a synthetic portfolio with permuted market data derived from the original security.
     * This step is repeated if the number of trades generated by the cloned strategy on the
     * synthetic data is less than a minimum threshold (defined by `BackTestResultPolicy::getMinStrategyTrades()`).
     * c. Running the backtest for the cloned strategy on the synthetic market data.
     * d. Computing a test statistic for this permutation using `BackTestResultPolicy::getPermutationTestStatistic()`.
     * e. Comparing the permutation's test statistic with the `baseLineTestStat`.
     * f. Updating a collection of test statistics via `_PermutationTestStatisticsCollectionPolicy` (thread-safe)
     *.
     * 2. These steps are executed in parallel for all permutations, as governed by the `Executor` policy.
     *
     * 3. Calculating the p-value as the proportion of permutations whose test statistic is greater than or
     * equal to the `baseLineTestStat`.
     *
     * 4. Obtaining a summary test statistic from the `_PermutationTestStatisticsCollectionPolicy`.
     *
     * 5. Returning the results as defined by the `_PermutationTestResultPolicy`.
     *
     * @param theBackTester A shared pointer to a `BackTester<Decimal>` object, which
     * encapsulates the backtesting engine and the trading strategy.
     * @param numPermutations The number of permutations (synthetic backtests) to run.
     * @param baseLineTestStat The test statistic obtained from running the strategy on the
     * original, unpermuted market data. This serves as the benchmark.
     * @return ReturnType The result of the permutation test, with its type determined by
     * the `_PermutationTestResultPolicy`. This typically includes the p-value
     * and may include a summary test statistic from the permutations.
     */
    static ReturnType
    runPermutationTest (std::shared_ptr<BackTester<Decimal>> theBackTester,
                        uint32_t numPermutations,
                        const Decimal& baseLineTestStat)
    {
      std::shared_ptr<BacktesterStrategy<Decimal>> aStrategy =
          (*(theBackTester->beginStrategies()));

      shared_ptr<Security<Decimal>> theSecurity = aStrategy->beginPortfolio()->second;

      // Shared, thread‐safe counters & stats
      std::atomic<uint32_t>                           count{0};
      _PermutationTestStatisticsCollectionPolicy      testStatisticCollection;
      std::mutex                                      testStatMutex;

      // Our executor policy
      Executor executor{};

      // Define the work for one permutation index 'p'
      auto work = [=, &count, &testStatisticCollection, &testStatMutex]
                  (uint32_t /*p*/)
      {
        // 1) clone until you have enough trades
        uint32_t stratTrades = 0;
        std::shared_ptr<BacktesterStrategy<Decimal>> clonedStrat;
        std::shared_ptr<BackTester<Decimal>>         clonedBT;

        while (stratTrades < BackTestResultPolicy::getMinStrategyTrades())
        {
          clonedStrat = aStrategy->clone(
            createSyntheticPortfolio<Decimal>(theSecurity, aStrategy->getPortfolio())
          );
          clonedBT = theBackTester->clone();
          clonedBT->addStrategy(clonedStrat);
          clonedBT->backtest();

          stratTrades = BackTesterFactory<Decimal>::getNumClosedTrades<Decimal>(clonedBT);
        }

        // 2) compute the statistic
        Decimal testStatistic = BackTestResultPolicy::getPermutationTestStatistic(clonedBT);

        // 3) count if ≥ baseline
        if (testStatistic >= baseLineTestStat)
          count.fetch_add(1, std::memory_order_relaxed);

        // 4) safely update the summary statistic
        {
          std::lock_guard<std::mutex> lock(testStatMutex);
          testStatisticCollection.updateTestStatistic(testStatistic);
        }
      };

      // Run all permutations in parallel
      concurrency::parallel_for(numPermutations, executor, work);

      // Finalize p-value and summary test stat
      Decimal pValue(Decimal(count.load()) / Decimal(numPermutations));
      Decimal summaryTestStat(testStatisticCollection.getTestStat());

      // Return whatever the policy dictates (e.g. pValue only, or tuple)
      return _PermutationTestResultPolicy::createReturnValue(pValue, summaryTestStat);
     }
  };
}
#endif
